#!/bin/sh

# bl-recent-files-pipemenu - an openbox pipemenu for recent files
# Copyright (C) 2015 Jens John <dev@2ion.de>
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

BOOKMARKS_FILE=
COMMON_NAME=recently-used.xbel
MAXIMUM_ENTRIES=999
OPEN_COMMAND=xdg-open
ORIGINAL_HANDLER=0
INCL_CLEAR_BOOKMARKS=0

FILE_COLUMN_PROGNAME=$(mktemp)
FILE_COLUMN_EXECNAME=$(mktemp)
FILE_COLUMN_FILENAME=$(mktemp)
FILE_COLUMNS=$(mktemp)

_TEMPLATE_ITEM='
  <item label="%s">
    <action name="Execute">
      <command>
        %s "%s"
      </command>
    </action>
  </item>'

_TEMPLATE_BEGIN='
<openbox_pipe_menu>'

_TEMPLATE_END='
</openbox_pipe_menu>'

_TEMPLATE_CLEANBOOKMARKS='
  <separator />
  <item label="Clear recent files">
    <action name="Execute">
      <command>
        rm --one-file-system -- "%s"
      </command>
    </action>
  </item>'

OUTPUT_BUFFER=""

log () {
  echo "$@" >&2
}

die () {
  log "$@"
  exit 1
}

detect_bookmarks_file () {
  local SUFFIX=$1
  for CANDIDATE in                        \
      "${XDG_DATA_HOME}/${SUFFIX}"        \
      "${HOME}/.local/share/${SUFFIX}"    \
      "${HOME}/.${SUFFIX}" ; do
    if test -r "${CANDIDATE}" ; then
      echo "${CANDIDATE}"
      return 0
    fi
  done
  return 1
}

mk_application_name_column () {
  local infile=$1
  local outfile=$2
  xmllint \
    --format \
    --xpath "/xbel/bookmark/info/metadata/*[local-name()='applications']/*[local-name()='application']/@name" \
    "$infile" \
    | sed 's_ name=_\nname=_g' \
    > "$outfile"
}

mk_application_exec_column () {
  local infile=$1
  local outfile=$2
  xmllint \
    --format \
    --xpath "/xbel/bookmark/info/metadata/*[local-name()='applications']/*[local-name()='application']/@exec" \
    "$infile" \
    | sed 's_ exec=_\nexec=_g' \
    > "$outfile"
}

mk_application_file_column () {
  local infile=$1
  local outfile=$2
  xmllint \
    --xpath "/xbel/bookmark/@href" \
    "$infile" \
    | sed 's_ href=_\nhref=_g' \
    > "$outfile"
}

mk_columns () {
  local infile=$1
  mk_application_file_column "$infile" "$FILE_COLUMN_FILENAME"
  mk_application_exec_column "$infile" "$FILE_COLUMN_EXECNAME"
  mk_application_name_column "$infile" "$FILE_COLUMN_PROGNAME"
  paste "$FILE_COLUMN_PROGNAME" "$FILE_COLUMN_EXECNAME" "$FILE_COLUMN_FILENAME" > "$FILE_COLUMNS"
}

decode_url () {
  local url=$1
  perl -MURI::Escape -e 'print uri_unescape($ARGV[0]);' "$url"
}

mk_list_item () {
  local label=$1
  local command=$2
  local arg=$3
  printf "$_TEMPLATE_ITEM" "$(decode_url "$label")" "$command" "$arg"
}

mk_list_item_with_handler () {
  local label=$1
  local executor="$2"
  local arg=$3
  local appname=$4

  executor=$(echo "$executor" | tr -d "'%u")
  
  printf "$_TEMPLATE_ITEM" "${appname}: $(decode_url "$label")" "$executor" "$arg"
}

mk_cleanbookmarks_item () {
  local bookmarksfile="$1"
  printf "$_TEMPLATE_CLEANBOOKMARKS" "$bookmarksfile"
}

cleanup () {
  rm -f "$FILE_COLUMNS" "$FILE_COLUMN_PROGNAME" "$FILE_COLUMN_FILENAME" "$FILE_COLUMN_EXECNAME"
}

clear_bookmarks () {
  local file=$1
  echo > "$file"
}

usage () {
  echo "Usage:  ${0##*/} [-Hch] [-f FILE] [-m MAX-ENTRIES] [-o OPEN-CMD]
        Where:  -H              Open recent files with their associated application.
                -c              Include a menu entry for clearing the recently used files.
                -f FILE         Use the .xbel file from the specified location instead of
                                trying to auto-detect it.
                -h              Print this message and exit.
                -m MAX-ENTRIES  Set the number of menu items to include, ignore the rest.
                -o OPEN-CMD     When not using -H, use OPEN-CMD to open any recent files.
                                Defaults to xdg-open."
}

# main ()

# process command line options

while getopts Hcf:hm:o: OPT ; do
  case "$OPT" in
    H)  ORIGINAL_HANDLER=1        ;;
    c)  INCL_CLEAR_BOOKMARKS=1    ;;
    f)  BOOKMARKS_FILE=$OPTARG    ;;
    h)  usage ; exit 0            ;;
    m)  MAXIMUM_ENTRIES=$OPTARG   ;;
    o)  OPEN_COMMAND=$OPTARG      ;;
    *)  exit 1                    ;; 
  esac
done

# probe for the user-provided file, or try to auto-detect a file

if test -n "${BOOKMARKS_FILE}" ; then
  # check user-provided file for validity
  if ! test -r "${BOOKMARKS_FILE}" ; then
    die "cannot read file: ${BOOKMARKS_FILE}" 
  fi
else
  # try to auto-detect a file
  BOOKMARKS_FILE=$(detect_bookmarks_file "${COMMON_NAME}")
  if test $? -ne 0 ; then
    die "failed to detect a recently-used file"
  fi
fi

mk_columns "$BOOKMARKS_FILE"

COUNT=0 ; while read LINE ; do
  if test -z "$LINE" ; then continue ; fi

  # $name := application name
  # $exec := command
  # $href := file argument
  eval "$LINE" || continue

  if test $ORIGINAL_HANDLER -eq 1 ; then
    OUTPUT_BUFFER="${OUTPUT_BUFFER} $(mk_list_item_with_handler "$(basename "$href")" "$exec" "$href" "$name")"
  else
    OUTPUT_BUFFER="${OUTPUT_BUFFER} $(mk_list_item "$(basename "$href")" "$OPEN_COMMAND" "$href")"
  fi

  COUNT=$(( COUNT + 1 ))
  if test $COUNT -eq $MAXIMUM_ENTRIES ; then break ; fi

done < "$FILE_COLUMNS"

# output

echo "$_TEMPLATE_BEGIN"

echo "$OUTPUT_BUFFER"

if test $INCL_CLEAR_BOOKMARKS -eq 1 ; then
  mk_cleanbookmarks_item "$BOOKMARKS_FILE"
fi

echo "$_TEMPLATE_END"

cleanup 
exit 0
