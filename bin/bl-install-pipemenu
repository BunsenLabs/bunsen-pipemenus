#!/bin/bash
#    bl-install-pipemenu - a jgmenu pipemenu for installing applications
#    Copyright (C) 2012 Philip Newborough   <corenominal@corenominal.org>
#    Copyright (C) 2015 damo    <damo@bunsenlabs.org>
#    Copyright (C) 2018 Matthew T Hoare <matthew.t.hoare@gmail.com>
#    Copyright (C) 2015-2019 John Crawley    <john@bunsenlabs.org>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.


HELP='    bl-install-pipemenu a jgmenu Pipe Menu for installing applications
    It should normally be called from a jgmenu menu.

Options (usually passed from the menu):
    -h --help   show this message
    --install   install a package
    (the package must be in the one of the app lists in this file)

    If bl-install-pipemenu is called with no options (the usual method),
    it will output a csv jgmenu pipemenu for installing applications.

'
###############################################

# jgmenu versions of OB menu creation functions
# These can be provided by /usr/lib/bunsen/common/bl-includes for any pipemenu.

# Associative arrays submenu_header and submenu_content are generated.
# submenu_header holds the submenu tag headers, and submenu_content holds the items.
# They are merged at jgmenuEnd().
# This allows a script to judge if the submenu is empty or not.

# not used at present
jgmenuStart() {
    :
}

# Usage: jgmenuItem label command
jgmenuItem() {
    printf '%s\n' "\"\"\"${1}\"\"\"","\"\"\"${2}\"\"\""
}

# Usage: jgmenuSeparator [label]
jgmenuSeparator() {
    printf '%s\n' '^sep(${1-)'
}

# Usage jgmenuSubmenu tag label
jgmenuSubmenu() {
    declare -Ag submenu_header
    submenu_header[$1]="^tag($1)"$'\nBack,^back()\n'
    printf '%s\n' "${2},^checkout($1)"
}

# Usage jgmenuSubmenuItem tag label command
jgmenuSubmenuItem(){
    declare -Ag submenu_content
    submenu_content[$1]+="\"\"\"${2}\"\"\"","\"\"\"${3}\"\"\""$'\n'
}

# Usage jgmenuSubmenuSeparator tag [label]
jgmenuSubmenuSeparator(){
    submenu_content[$1]+='^sep(${2-)'
}

# not used
jgmenuSubmenuEnd() {
    :
}

# Add submenu definitions after root menu
jgmenuEnd() {
    for i in "${!submenu_header[@]}"
    do
        printf '%b\n' "${submenu_header[$i]}${submenu_content[$i]}"
    done
}

########## end jgmenu functions ################

# install apps lists
MM_APPS=('mpv' 'vlc' 'audacious' 'smplayer' 'gnome-mpv')
MM_EDITORS=('mhwaveedit' 'audacity' 'openshot')
MM_UTILS=('xfburn' 'brasero' 'k3b' 'gtk-recordmydesktop' )
GRAPHICS_APPS=( 'mirage' 'viewnior' 'gpicview' 'ristretto' 'geeqie' 'gimp' 'inkscape')
GRAPHICS_SCROTS=('xfce4-screenshooter' 'scrot')

# associative array: commands which are different from package names
# These commands are used to test if the package is installed or not.
# If the package command is the same as its name it is not necessary to define it.
# If a package provides several commands, it is enough to define one.
declare -A pkg_cmd
#pkg_cmd[mpv]='bl-mpv'

########################################################################

# look for a help option somewhere
for i in "$@"
do
    case "$i" in
    -h|--help)
        echo "$HELP"
        exit 0
        ;;
    esac
done

BL_COMMON_LIBDIR='/usr/lib/bunsen/common'

if ! . "$BL_COMMON_LIBDIR/bl-includes" 2> /dev/null; then
    echo "Error: Failed to source bl-includes in $BL_COMMON_LIBDIR" >&2
    exit 1
fi

declare -A AppName AppStatus

for curApp in "${MM_APPS[@]}" "${MM_EDITORS[@]}" "${MM_UTILS[@]}" "${GRAPHICS_APPS[@]}" "${GRAPHICS_SCROTS[@]}"; do
    words=(${curApp//-/ })
    AppName[$curApp]="${AppName[$curApp]:-${words[*]^}}"
    AppCmd[$curApp]="${pkg_cmd[$curApp]:-$curApp}" # use packagename as command if not defined in pkg_cmd
    hash "${AppCmd[$curApp]}" 2>/dev/null && AppStatus[$curApp]='installed' || AppStatus[$curApp]=''
done

appExists() {
    for curApp in "${!AppName[@]}"; do # if $packageName exists in MM_APPS MM_EDITORS MM_UTILS arrays
        [[ $curApp = "$1" ]] &&
            return 0
    done
    say "Unable to install $1. There is no such application that I know of." 1 >&2
    say "You can try one of these: ${MM_APPS[*]} ${MM_EDITORS[*]} ${MM_UTILS[*]}" 2 >&2
    return 1
}

# If the package needs additional configuration before installation
# create a function called setupAppName, it will be called automatically.
# (This capability is not needed at the moment.)

# obsolete example:
#setupGoogleChromeStable() {
#    addAptKey "${KEY_URLS_GOOGLE[@]}" || return 1
#    say 'Creating APT sources file...' 1
#    echo 'deb http://dl.google.com/linux/chrome/deb/ stable main' | sudo tee '/etc/apt/sources.list.d/google-chrome.list'
#}

if [[ ${1-} = --install ]]; then
    packageName=$2
    appName=${AppName[$packageName]}
    appExists "$packageName" || exit 1
    desc="This script will install $appName."
    setupFunctionName="setup${appName//[^a-zA-Z]/}" # setupFunctionName should now be in format like 'setupChromium'
    if [[ $(type -t "$setupFunctionName") = 'function' ]]; then
        "$setupFunctionName" || { echo "$0: function $setupFunctionName failed." >&2; exit 1;} # run setup function if it exists
    fi
    bl-install --name "$appName" --message "$desc" "$packageName"

elif [[ ${1-} ]]; then
    echo "$0: no such option $*" >&2
    exit 1

else # pipemenu

    # This function is specific to this script.
    # Usage: generate_installmenu tag label list (of packagenames)
    generate_installmenu() {
        local tag=$1
        local label=$2
        shift 2
        for curApp in "${@}"; do
            if ! [[ ${AppStatus[$curApp]} = installed ]]; then
                jgmenuSubmenuItem "$tag" "Install ${AppName[$curApp]}" "$0 --install $curApp"
            fi
        done
        [[ -n ${submenu_content[$tag]} ]] && jgmenuSubmenu "$tag" "$label"
    }

    generate_installmenu 'mmapps' 'Multimedia Apps'  "${MM_APPS[@]}"
    generate_installmenu 'mmeditors' 'Multimedia Editors' "${MM_EDITORS[@]}"
    generate_installmenu 'mmutils' 'Multimedia Utilities' "${MM_UTILS[@]}"
    generate_installmenu 'graphicapps' 'Graphics Apps' "${GRAPHICS_APPS[@]}"
    generate_installmenu 'graphicscrots' 'Graphics Scrots' "${GRAPHICS_SCROTS[@]}"

    jgmenuEnd

#    menuEnd
fi
exit 0
